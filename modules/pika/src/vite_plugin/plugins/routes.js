import fs from 'fs';
import path from 'path';
import { walk, with_leading_slash, without_trailing_slash } from '../utils.js';
import { genArrayFromRaw, genDynamicImport } from 'knitwork';

/**
 * @param {Required<import('~/types/mod').PluginSettings>} settings
 * @returns {import('vite').Plugin}
 */
export function plugin_routes(settings) {
  /** @type {string} */
  let root;

  return {
    name: 'pika:routes',
    configResolved(config) {
      root = config.root;
    },
    configureServer(server) {
      const file_to_write = path.join(root, settings.appDir, 'pika.gen.js');
      const update_manifest = async () => {
        fs.writeFileSync(file_to_write, await generate_routes(root, settings));
      };
      update_manifest();
      server.watcher.on('add', update_manifest);
      server.watcher.on('unlink', update_manifest);
    },
  };
}

/**
 * @param {string} root
 * @param {Required<import('~/types/mod').PluginSettings>} settings
 */
async function generate_routes(root, settings) {
  const app_dir = path.resolve(root, settings.appDir);
  const routes_dir = path.resolve(app_dir, settings.routesDir);
  const files = [];

  for await (const file of walk(routes_dir, /^\./)) {
    files.push(file);
  }

  files.sort();
  const views = [];
  const endpoints = [];
  const s = JSON.stringify;

  for (const file of files) {
    const relative_file = './' + path.relative(app_dir, file);
    const filename = path
      .relative(routes_dir, file)
      .replace(/\.(?:vue|js|ts)$/, '');

    if (file.endsWith('.js') || file.endsWith('.ts')) {
      endpoints.push({
        pathname: s(to_route_path(filename)),
        load: genDynamicImport(relative_file),
      });
    } else if (file.endsWith('.vue')) {
      const shadow_endpoint_file_js = file.replace(/\.vue$/, '.js');
      const shadow_endpoint_file_ts = file.replace(/\.vue$/, '.ts');
      const relative_shadow_file = files.includes(shadow_endpoint_file_js)
        ? path.relative(app_dir, shadow_endpoint_file_js)
        : files.includes(shadow_endpoint_file_ts)
        ? path.relative(app_dir, shadow_endpoint_file_ts)
        : null;
      const shadow = relative_shadow_file
        ? `import.meta.env.SSR ? ${genDynamicImport(
            './' + relative_shadow_file,
          )} : null`
        : null;
      views.push({
        path: s(to_route_path(filename)),
        component: genDynamicImport(relative_file),
        props: true,
        ...(shadow ? { meta: { shadow } } : {}),
      });
    }
  }

  const views_str = `export const views = ${genArrayFromRaw(views)};`;

  const endpoints_str = `export const endpoints = ${genArrayFromRaw(
    endpoints,
  )};`;

  return `// DO NOT EDIT. Generated by "pika:routes" plugin of Pika.
// This file should be checked into version control.

${views_str}

${endpoints_str}
`;
}

/** @param {string} file */
export function to_route_path(file) {
  let pathname = file;

  if (file.endsWith('_')) {
    pathname = file.replace(/_/g, ':') + '*';
  } else if (/(?<!_)_{1}(?!_)/g.test(file)) {
    pathname = file.replace(/_/g, ':');
  } else if (file.includes('_')) {
    // TODO: handle edge case like $/nested/$.vue
    throw new Error(`Invalid route file ${file}.vue`);
  }

  if (pathname.endsWith('index')) {
    pathname = pathname.replace(/index$/, '');
  }

  return with_leading_slash(without_trailing_slash(pathname));
}
